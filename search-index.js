var searchIndex={};
searchIndex["libslide"] = {"doc":"","i":[[3,"Bignum","libslide","",null,null],[12,"is_neg","","",0,null],[12,"int","","",0,null],[12,"dec","","",0,null],[3,"EvaluatorContext","","",null,null],[12,"rule_blacklist","","",1,null],[5,"scan","","",null,[[["into",["string"]],["string"]],[["vec",["token"]],["token"]]]],[5,"parse_expression","","",null,[[["vec",["token"]],["token"]]]],[5,"parse_expression_pattern","","",null,[[["vec",["token"]],["token"]]]],[5,"evaluate","","Evaluates an expression to as simplified a form as…",null,[[["evaluatorcontext"],["stmt"]],[["box",["error"]],["result",["expr","box"]],["expr"]]]],[0,"bignum","","",null,null],[3,"Bignum","libslide::bignum","",null,null],[12,"is_neg","","",0,null],[12,"int","","",0,null],[12,"dec","","",0,null],[5,"to_u8","","",null,[[["char"]],["u8"]]],[5,"to_char","","",null,[[["u8"]],["char"]]],[0,"add","","",null,null],[0,"compare","","",null,null],[0,"complex","","",null,null],[3,"Complex","libslide::bignum::complex","",null,null],[12,"real","","",2,null],[12,"imag","","",2,null],[7,"INPUT_ERR_MSG","","",null,null],[17,"TOLERANCE","","",null,null],[11,"new","","",2,[[["f64"]],["complex"]]],[11,"real","","",2,[[],["f64"]]],[11,"imag","","",2,[[],["f64"]]],[11,"conjg","","",2,[[],["complex"]]],[11,"round","","",2,[[],["complex"]]],[11,"exp","","",2,[[],["complex"]]],[0,"mul","libslide::bignum","",null,null],[0,"negate","","",null,null],[0,"sub","","",null,null],[0,"utils","","",null,null],[5,"recast_vec","libslide::bignum::utils","",null,[[["vec"]],["vec"]]],[5,"recast_user_vec","","",null,[[["vec"]],[["str"],["result",["vec","str"]],["vec"]]]],[5,"truncate_zeros","","",null,[[["vec",["u8"]],["u8"]],[["vec",["u8"]],["u8"]]]],[5,"normalize_vecs","","",null,[[["vec",["u8"]],["u8"]]]],[5,"abs","","",null,[[["bignum"]],["bignum"]]],[5,"ispowerof2","","",null,[[["usize"]],["bool"]]],[5,"fft","","",null,[[["complex"],["usize"],["vec",["complex"]],["bool"]],[["complex"],["vec",["complex"]]]]],[5,"ifft","","",null,[[["complex"],["vec",["complex"]],["usize"]],[["complex"],["vec",["complex"]]]]],[5,"convert_poly","","",null,[[["u16"],["vec",["u16"]]],[["vec",["u8"]],["u8"]]]],[7,"ERR_MSG","","",null,null],[17,"TOLERANCE","","",null,null],[7,"INPUT_ERR_MSG","libslide::bignum","",null,null],[11,"new","libslide","",0,[[["string"]],[["result",["bignum","str"]],["bignum"],["str"]]]],[0,"scanner","","",null,null],[3,"Scanner","libslide::scanner","",null,null],[12,"input","","",3,null],[12,"output","","",3,null],[5,"scan","","",null,[[["into",["string"]],["string"]],[["vec",["token"]],["token"]]]],[0,"types","","",null,null],[3,"Token","libslide::scanner::types","",null,null],[12,"ty","","",4,null],[4,"TokenType","","",null,null],[13,"Float","","",5,null],[13,"Plus","","",5,null],[13,"Minus","","",5,null],[13,"Mult","","",5,null],[13,"Div","","",5,null],[13,"Mod","","",5,null],[13,"Exp","","",5,null],[13,"Equal","","",5,null],[13,"OpenParen","","",5,null],[13,"CloseParen","","",5,null],[13,"OpenBracket","","",5,null],[13,"CloseBracket","","",5,null],[13,"Variable","","",5,null],[13,"VariablePattern","","",5,null],[13,"ConstPattern","","",5,null],[13,"AnyPattern","","",5,null],[13,"Invalid","","",5,null],[13,"EOF","","",5,null],[11,"new","","",4,[[["tokentype"]],["self"]]],[11,"new","libslide::scanner","",3,[[["into",["string"]],["string"]],["scanner"]]],[11,"scan","","",3,[[["self"]]]],[11,"scan_symbol","","",3,[[["self"]]]],[11,"scan_num","","",3,[[["self"]]]],[11,"scan_var_str","","",3,[[["self"]],["string"]]],[11,"scan_var","","",3,[[["self"]]]],[11,"scan_var_pattern","","",3,[[["self"]]]],[11,"scan_const_pattern","","",3,[[["self"]]]],[11,"scan_any_pattern","","",3,[[["self"]]]],[0,"parser","libslide","",null,null],[0,"test_utils","libslide::parser","",null,null],[0,"expression_parser","","",null,null],[3,"ExpressionParser","libslide::parser::expression_parser","",null,null],[12,"_input","","",6,null],[12,"_errors","","",6,null],[12,"seen","","",6,null],[5,"parse","","",null,[[["vec",["token"]],["token"]]]],[11,"assignment","","",6,[[["self"],["string"]],["stmt"]]],[11,"parse_pattern","","",6,[[["self"],["string"]],["expr"]]],[0,"expression_pattern_parser","libslide::parser","",null,null],[3,"ExpressionPatternParser","libslide::parser::expression_pattern_parser","",null,null],[12,"_input","","",7,null],[12,"_errors","","",7,null],[12,"seen","","",7,null],[5,"parse","","",null,[[["vec",["token"]],["token"]]]],[8,"Parser","libslide::parser","",null,null],[16,"Expr","","",8,null],[16,"Error","","",8,null],[10,"new","","",8,[[["vec",["token"]],["token"]],["self"]]],[10,"errors","","",8,[[["self"]],["vec"]]],[10,"input","","",8,[[["self"]],["peekiter"]]],[10,"parse","","",8,[[["self"]],["t"]]],[10,"parse_float","","",8,[[["self"],["f64"]]]],[10,"parse_variable","","",8,[[["self"],["string"]]]],[10,"parse_var_pattern","","",8,[[["self"],["string"]]]],[10,"parse_const_pattern","","",8,[[["self"],["string"]]]],[10,"parse_any_pattern","","",8,[[["self"],["string"]]]],[10,"parse_open_paren","","",8,[[["self"]]]],[10,"parse_open_brace","","",8,[[["self"]]]],[10,"finish_expr","","",8,[[["self"]],["rc"]]],[11,"done","","",8,[[["self"]],["bool"]]],[11,"expr","","",8,[[["self"]],["rc"]]],[11,"add_sub_term","","",8,[[["self"]],["rc"]]],[11,"mul_divide_mod_term","","",8,[[["self"]],["rc"]]],[11,"exp_term","","",8,[[["self"]],["rc"]]],[11,"num_term","","",8,[[["self"]],["rc"]]],[0,"partial_evaluator","libslide","",null,null],[5,"evaluate","libslide::partial_evaluator","Evaluates an expression to as simplified a form as…",null,[[["evaluatorcontext"],["stmt"]],[["box",["error"]],["result",["expr","box"]],["expr"]]]],[0,"types","","",null,null],[3,"EvaluatorContext","libslide::partial_evaluator::types","",null,null],[12,"rule_blacklist","","",1,null],[11,"with_blacklist","libslide","",1,[[["t"]],["self"]]],[0,"evaluator_rules","","",null,null],[0,"pattern_match","libslide::evaluator_rules","",null,null],[3,"PatternMatch","libslide::evaluator_rules::pattern_match","Represents pattern-matched replacements betwen a rule and…",null,null],[12,"map","","",9,null],[8,"MatchRule","","",null,null],[10,"match_rule","","Pattern matches a rule template against an expression. If…",10,[[["rc",["exprpat"]],["exprpat"],["rc"]],[["option",["patternmatch"]],["patternmatch"]]]],[11,"try_merge","","Merges two `PatternMatch`. If the `PatternMatch` are of…",9,[[["patternmatch"]],[["option",["patternmatch"]],["patternmatch"]]]],[11,"insert","","",9,[[["self"],["rc"],["rc"]],[["rc"],["option",["rc"]]]]],[0,"registry","libslide::evaluator_rules","",null,null],[3,"RuleSet","libslide::evaluator_rules::registry","Set of unbuilt rules.",null,null],[12,"rules","","",11,null],[12,"custom_rules","","",11,null],[3,"BuildRuleErrors","","",null,null],[12,"errors","","",12,null],[4,"RuleName","","",null,null],[13,"UnwrapExplicitParens","","",13,null],[13,"UnwrapExplicitBrackets","","",13,null],[13,"Add","","",13,null],[13,"Subtract","","",13,null],[13,"Multiply","","",13,null],[13,"Divide","","",13,null],[13,"Modulo","","",13,null],[13,"Exponentiate","","",13,null],[13,"Posate","","",13,null],[13,"Negate","","",13,null],[13,"MultiplicateIdentity","","",13,null],[13,"AdditiveIdentity","","",13,null],[13,"AdditiveInverse","","",13,null],[13,"ReorderConstants","","",13,null],[13,"DistributeNegation","","",13,null],[13,"FoldNegatedAddition","","",13,null],[5,"get_all_rules","","",null,[[],[["hashmap",["rulename","unbuiltrule"]],["rulename"],["unbuiltrule"]]]],[0,"fn_rules","","",null,null],[5,"add","libslide::evaluator_rules::registry::fn_rules","",null,[[["rc",["expr"]],["expr"]],[["option",["rc"]],["rc",["expr"]]]]],[5,"subtract","","",null,[[["rc",["expr"]],["expr"]],[["option",["rc"]],["rc",["expr"]]]]],[5,"multiply","","",null,[[["rc",["expr"]],["expr"]],[["option",["rc"]],["rc",["expr"]]]]],[5,"divide","","",null,[[["rc",["expr"]],["expr"]],[["option",["rc"]],["rc",["expr"]]]]],[5,"modulo","","",null,[[["rc",["expr"]],["expr"]],[["option",["rc"]],["rc",["expr"]]]]],[5,"exponentiate","","",null,[[["rc",["expr"]],["expr"]],[["option",["rc"]],["rc",["expr"]]]]],[5,"posate","","",null,[[["rc",["expr"]],["expr"]],[["option",["rc"]],["rc",["expr"]]]]],[5,"negate","","",null,[[["rc",["expr"]],["expr"]],[["option",["rc"]],["rc",["expr"]]]]],[11,"build","libslide::evaluator_rules::registry","Creates a list of `Rules`s from the unbuilt rule set.",11,[[["self"]],[["result",["vec","buildruleerrors"]],["vec",["rule"]],["buildruleerrors"]]]],[11,"remove","","Remove a named rule from the rule set.",11,[[["self"],["rulename"]]]],[11,"insert_custom","","Insert a custom unbuilt rule into the rule set.",11,[[["self"],["into",["unbuiltrule"]],["unbuiltrule"]]]],[11,"get_bootstrapping_rules","","Retrieves a set of rules to be used in bootstrapping other…",11,[[],[["vec",["rule"]],["rule"]]]],[11,"get_boostrap_blacklist","","Retrieves a set of rules to be excluded from being…",11,[[],[["option",["rulename"]],["hashset",["option"]]]]],[0,"rule","libslide::evaluator_rules","",null,null],[3,"PatternMap","libslide::evaluator_rules::rule","A mapping between two expression patterns.",null,null],[12,"from","","",14,null],[12,"to","","",14,null],[3,"UnresolvedMapping","","",null,null],[12,"map","","",15,null],[12,"unresolved_pats","","",15,null],[4,"Rule","","",null,null],[13,"PatternMap","","",16,null],[13,"Evaluate","","",16,null],[5,"fn_name","","",null,[[["t"]],["str"]]],[11,"from_str","","Converts a string representation of a rule to a…",14,[[["str"]],["self"]]],[11,"bootstrap","","Bootstraps a `PatternMap` rule with a one-pass application…",14,[[["self"]],["self"]]],[11,"validate","","Checks a `PatternMap` is resolvable, returning an error if…",14,[[["self"]],[["option",["unresolvedmapping"]],["unresolvedmapping"]]]],[11,"from_fn","","",16,[[],["self"]]],[0,"unbuilt_rule","libslide::evaluator_rules","",null,null],[4,"UnbuiltRule","libslide::evaluator_rules::unbuilt_rule","An unbuilt rule, generally used to express a rule in a…",null,null],[13,"S","","An expression-mapping rule.",17,null],[13,"F","","A function rule.",17,null],[0,"grammar","libslide","",null,null],[3,"Assignment","libslide::grammar","",null,null],[12,"var","","",18,null],[12,"rhs","","",18,null],[3,"BinaryExpr","","",null,null],[12,"op","","",19,null],[12,"lhs","","",19,null],[12,"rhs","","",19,null],[3,"UnaryExpr","","",null,null],[12,"op","","",20,null],[12,"rhs","","",20,null],[4,"Stmt","","",null,null],[13,"Expr","","",21,null],[13,"Assignment","","",21,null],[4,"Expr","","",null,null],[13,"Const","","",22,null],[13,"Var","","",22,null],[13,"BinaryExpr","","",22,null],[13,"UnaryExpr","","",22,null],[13,"Parend","","An expression wrapped in parentheses",22,null],[13,"Braced","","An expression wrapped in braces",22,null],[4,"BinaryOperator","","",null,null],[13,"Plus","","",23,null],[13,"Minus","","",23,null],[13,"Mult","","",23,null],[13,"Div","","",23,null],[13,"Mod","","",23,null],[13,"Exp","","",23,null],[4,"UnaryOperator","","",null,null],[13,"SignPositive","","",24,null],[13,"SignNegative","","",24,null],[0,"pattern","","",null,null],[4,"ExprPat","libslide::grammar::pattern","",null,null],[13,"Const","","",25,null],[13,"VarPat","","Pattern matching a variable",25,null],[13,"ConstPat","","Pattern matching a constant",25,null],[13,"AnyPat","","Pattern matching any expression",25,null],[13,"BinaryExpr","","",25,null],[13,"UnaryExpr","","",25,null],[13,"Parend","","",25,null],[13,"Braced","","",25,null],[0,"transformer","libslide::grammar","",null,null],[8,"Transformer","libslide::grammar::transformer","A trait for transforming one grammar into another. This…",null,null],[10,"transform","","",26,[[["self"],["t"]],["u"]]],[8,"Grammar","libslide::grammar","",null,null],[8,"Expression","","",null,null],[10,"is_const","","",27,[[["self"]],["bool"]]],[11,"complexity","","",22,[[["self"]],["u8"]]],[0,"math","libslide","",null,null],[0,"gcd","libslide::math","",null,null],[5,"gcd","libslide::math::gcd","Calculates the GCD for (u, v) ∈ (Z, Z).",null,[[["unsigned"],["primint"]],[["unsigned"],["primint"]]]],[5,"binary_gcd","","The [Binary GCD] algorithm, or Stein's algorithm.…",null,[[["unsigned"],["primint"]],[["unsigned"],["primint"]]]],[5,"euclidean_gcd","","The [Euclidean GCD] algorithm. Implemented ∀ (u, v) ∈ (Z,…",null,[[["unsigned"],["primint"]],[["unsigned"],["primint"]]]],[0,"utils","libslide","",null,null],[0,"grammar","libslide::utils","",null,null],[4,"UnflattenStrategy","libslide::utils::grammar","",null,null],[13,"Left","","",28,null],[13,"Right","","",28,null],[5,"get_symmetric_expressions","","",null,[[["rc",["expr"]],["expr"]],[["rc",["expr"]],["vec",["rc"]]]]],[5,"get_flattened_binary_args","","",null,[[["rc",["expr"]],["binaryoperator"],["expr"]],[["rc",["expr"]],["vec",["rc"]]]]],[5,"negate","","",null,[[["rc",["expr"]],["expr"]],[["expr"],["rc",["expr"]]]]],[5,"unflatten_binary_expr","","",null,[[["binaryoperator"],["unflattenstrategy"]],["rc"]]],[5,"unique_pats","","Returns all unique patterns in a pattern expression.",null,[[["rc"]],[["rc"],["hashset",["rc"]]]]],[5,"normalize","","",null,[[["rc",["expr"]],["expr"]],[["expr"],["rc",["expr"]]]]],[0,"hash","libslide::utils","",null,null],[5,"hash","libslide::utils::hash","",null,[[["t"]],["u64"]]],[0,"iter","libslide::utils","",null,null],[3,"PeekingTakeWhile","libslide::utils::iter","A [`TakeWhile`]-like struct that tests a predicate by…",null,null],[12,"peeker","","A mutable reference to the underlying iterator is taken…",29,null],[12,"predicate","","",29,null],[3,"PeekIter","","An iterator that supports arbitrary-length peeking.",null,null],[12,"iter","","",30,null],[12,"lookahead","","A store of items we had to consume from the iterator for…",30,null],[11,"new","","",29,[[["peekiter"],["p"]],["self"]]],[11,"new","","",30,[[["intoiter"]],["self"]]],[11,"peek","","Returns a reference to the next value in the iterator,…",30,[[["self"]],[["t"],["option"]]]],[11,"peek_map_n","","Returns a deque of up to `n` peeked items mapped over a…",30,[[["self"],["usize"]],["vecdeque"]]],[11,"collect_while","","Collects items in the iteration while `predicate` returns…",30,[[["self"],["p"]],["c"]]],[11,"push_front","","Adds an item to the front of the current iteration.",30,[[["self"],["t"]]]],[0,"string","libslide::utils","",null,null],[5,"indent","libslide::utils::string","Indents all lines of a string with `n` spaces.",null,[[["usize"],["into",["string"]],["string"]],["string"]]],[8,"StringUtils","","",null,null],[10,"substring","","",31,[[["self"],["usize"]],["self"]]],[11,"from","libslide","",0,[[["t"]],["t"]]],[11,"into","","",0,[[],["u"]]],[11,"to_string","","",0,[[["self"]],["string"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"try_into","","",0,[[],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"type_id","","",0,[[["self"]],["typeid"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"into","","",1,[[],["u"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"try_into","","",1,[[],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"type_id","","",1,[[["self"]],["typeid"]]],[11,"from","libslide::bignum::complex","",2,[[["t"]],["t"]]],[11,"into","","",2,[[],["u"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,[[["self"],["t"]]]],[11,"to_string","","",2,[[["self"]],["string"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"try_into","","",2,[[],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"type_id","","",2,[[["self"]],["typeid"]]],[11,"from","libslide::scanner","",3,[[["t"]],["t"]]],[11,"into","","",3,[[],["u"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"try_into","","",3,[[],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"type_id","","",3,[[["self"]],["typeid"]]],[11,"from","libslide::scanner::types","",4,[[["t"]],["t"]]],[11,"into","","",4,[[],["u"]]],[11,"to_owned","","",4,[[["self"]],["t"]]],[11,"clone_into","","",4,[[["self"],["t"]]]],[11,"to_string","","",4,[[["self"]],["string"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"try_into","","",4,[[],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"type_id","","",4,[[["self"]],["typeid"]]],[11,"from","","",5,[[["t"]],["t"]]],[11,"into","","",5,[[],["u"]]],[11,"to_owned","","",5,[[["self"]],["t"]]],[11,"clone_into","","",5,[[["self"],["t"]]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"try_into","","",5,[[],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"type_id","","",5,[[["self"]],["typeid"]]],[11,"from","libslide::parser::expression_parser","",6,[[["t"]],["t"]]],[11,"into","","",6,[[],["u"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"try_into","","",6,[[],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"type_id","","",6,[[["self"]],["typeid"]]],[11,"from","libslide::parser::expression_pattern_parser","",7,[[["t"]],["t"]]],[11,"into","","",7,[[],["u"]]],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"try_into","","",7,[[],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"type_id","","",7,[[["self"]],["typeid"]]],[11,"from","libslide::evaluator_rules::pattern_match","",9,[[["t"]],["t"]]],[11,"into","","",9,[[],["u"]]],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"try_into","","",9,[[],["result"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"type_id","","",9,[[["self"]],["typeid"]]],[11,"from","libslide::evaluator_rules::registry","",11,[[["t"]],["t"]]],[11,"into","","",11,[[],["u"]]],[11,"try_from","","",11,[[["u"]],["result"]]],[11,"try_into","","",11,[[],["result"]]],[11,"borrow","","",11,[[["self"]],["t"]]],[11,"borrow_mut","","",11,[[["self"]],["t"]]],[11,"type_id","","",11,[[["self"]],["typeid"]]],[11,"from","","",12,[[["t"]],["t"]]],[11,"into","","",12,[[],["u"]]],[11,"to_string","","",12,[[["self"]],["string"]]],[11,"try_from","","",12,[[["u"]],["result"]]],[11,"try_into","","",12,[[],["result"]]],[11,"borrow","","",12,[[["self"]],["t"]]],[11,"borrow_mut","","",12,[[["self"]],["t"]]],[11,"type_id","","",12,[[["self"]],["typeid"]]],[11,"from","","",13,[[["t"]],["t"]]],[11,"into","","",13,[[],["u"]]],[11,"to_owned","","",13,[[["self"]],["t"]]],[11,"clone_into","","",13,[[["self"],["t"]]]],[11,"try_from","","",13,[[["u"]],["result"]]],[11,"try_into","","",13,[[],["result"]]],[11,"borrow","","",13,[[["self"]],["t"]]],[11,"borrow_mut","","",13,[[["self"]],["t"]]],[11,"type_id","","",13,[[["self"]],["typeid"]]],[11,"from","libslide::evaluator_rules::rule","",14,[[["t"]],["t"]]],[11,"into","","",14,[[],["u"]]],[11,"to_owned","","",14,[[["self"]],["t"]]],[11,"clone_into","","",14,[[["self"],["t"]]]],[11,"to_string","","",14,[[["self"]],["string"]]],[11,"try_from","","",14,[[["u"]],["result"]]],[11,"try_into","","",14,[[],["result"]]],[11,"borrow","","",14,[[["self"]],["t"]]],[11,"borrow_mut","","",14,[[["self"]],["t"]]],[11,"type_id","","",14,[[["self"]],["typeid"]]],[11,"from","","",15,[[["t"]],["t"]]],[11,"into","","",15,[[],["u"]]],[11,"to_string","","",15,[[["self"]],["string"]]],[11,"try_from","","",15,[[["u"]],["result"]]],[11,"try_into","","",15,[[],["result"]]],[11,"borrow","","",15,[[["self"]],["t"]]],[11,"borrow_mut","","",15,[[["self"]],["t"]]],[11,"type_id","","",15,[[["self"]],["typeid"]]],[11,"from","","",16,[[["t"]],["t"]]],[11,"into","","",16,[[],["u"]]],[11,"to_string","","",16,[[["self"]],["string"]]],[11,"try_from","","",16,[[["u"]],["result"]]],[11,"try_into","","",16,[[],["result"]]],[11,"borrow","","",16,[[["self"]],["t"]]],[11,"borrow_mut","","",16,[[["self"]],["t"]]],[11,"type_id","","",16,[[["self"]],["typeid"]]],[11,"from","libslide::evaluator_rules::unbuilt_rule","",17,[[["t"]],["t"]]],[11,"into","","",17,[[],["u"]]],[11,"to_owned","","",17,[[["self"]],["t"]]],[11,"clone_into","","",17,[[["self"],["t"]]]],[11,"try_from","","",17,[[["u"]],["result"]]],[11,"try_into","","",17,[[],["result"]]],[11,"borrow","","",17,[[["self"]],["t"]]],[11,"borrow_mut","","",17,[[["self"]],["t"]]],[11,"type_id","","",17,[[["self"]],["typeid"]]],[11,"from","libslide::grammar","",18,[[["t"]],["t"]]],[11,"into","","",18,[[],["u"]]],[11,"to_owned","","",18,[[["self"]],["t"]]],[11,"clone_into","","",18,[[["self"],["t"]]]],[11,"to_string","","",18,[[["self"]],["string"]]],[11,"try_from","","",18,[[["u"]],["result"]]],[11,"try_into","","",18,[[],["result"]]],[11,"borrow","","",18,[[["self"]],["t"]]],[11,"borrow_mut","","",18,[[["self"]],["t"]]],[11,"type_id","","",18,[[["self"]],["typeid"]]],[11,"from","","",19,[[["t"]],["t"]]],[11,"into","","",19,[[],["u"]]],[11,"to_owned","","",19,[[["self"]],["t"]]],[11,"clone_into","","",19,[[["self"],["t"]]]],[11,"to_string","","",19,[[["self"]],["string"]]],[11,"try_from","","",19,[[["u"]],["result"]]],[11,"try_into","","",19,[[],["result"]]],[11,"borrow","","",19,[[["self"]],["t"]]],[11,"borrow_mut","","",19,[[["self"]],["t"]]],[11,"type_id","","",19,[[["self"]],["typeid"]]],[11,"from","","",20,[[["t"]],["t"]]],[11,"into","","",20,[[],["u"]]],[11,"to_owned","","",20,[[["self"]],["t"]]],[11,"clone_into","","",20,[[["self"],["t"]]]],[11,"to_string","","",20,[[["self"]],["string"]]],[11,"try_from","","",20,[[["u"]],["result"]]],[11,"try_into","","",20,[[],["result"]]],[11,"borrow","","",20,[[["self"]],["t"]]],[11,"borrow_mut","","",20,[[["self"]],["t"]]],[11,"type_id","","",20,[[["self"]],["typeid"]]],[11,"from","","",21,[[["t"]],["t"]]],[11,"into","","",21,[[],["u"]]],[11,"to_owned","","",21,[[["self"]],["t"]]],[11,"clone_into","","",21,[[["self"],["t"]]]],[11,"to_string","","",21,[[["self"]],["string"]]],[11,"try_from","","",21,[[["u"]],["result"]]],[11,"try_into","","",21,[[],["result"]]],[11,"borrow","","",21,[[["self"]],["t"]]],[11,"borrow_mut","","",21,[[["self"]],["t"]]],[11,"type_id","","",21,[[["self"]],["typeid"]]],[11,"from","","",22,[[["t"]],["t"]]],[11,"into","","",22,[[],["u"]]],[11,"to_owned","","",22,[[["self"]],["t"]]],[11,"clone_into","","",22,[[["self"],["t"]]]],[11,"to_string","","",22,[[["self"]],["string"]]],[11,"try_from","","",22,[[["u"]],["result"]]],[11,"try_into","","",22,[[],["result"]]],[11,"borrow","","",22,[[["self"]],["t"]]],[11,"borrow_mut","","",22,[[["self"]],["t"]]],[11,"type_id","","",22,[[["self"]],["typeid"]]],[11,"from","","",23,[[["t"]],["t"]]],[11,"into","","",23,[[],["u"]]],[11,"to_owned","","",23,[[["self"]],["t"]]],[11,"clone_into","","",23,[[["self"],["t"]]]],[11,"to_string","","",23,[[["self"]],["string"]]],[11,"try_from","","",23,[[["u"]],["result"]]],[11,"try_into","","",23,[[],["result"]]],[11,"borrow","","",23,[[["self"]],["t"]]],[11,"borrow_mut","","",23,[[["self"]],["t"]]],[11,"type_id","","",23,[[["self"]],["typeid"]]],[11,"from","","",24,[[["t"]],["t"]]],[11,"into","","",24,[[],["u"]]],[11,"to_owned","","",24,[[["self"]],["t"]]],[11,"clone_into","","",24,[[["self"],["t"]]]],[11,"to_string","","",24,[[["self"]],["string"]]],[11,"try_from","","",24,[[["u"]],["result"]]],[11,"try_into","","",24,[[],["result"]]],[11,"borrow","","",24,[[["self"]],["t"]]],[11,"borrow_mut","","",24,[[["self"]],["t"]]],[11,"type_id","","",24,[[["self"]],["typeid"]]],[11,"from","libslide::grammar::pattern","",25,[[["t"]],["t"]]],[11,"into","","",25,[[],["u"]]],[11,"to_owned","","",25,[[["self"]],["t"]]],[11,"clone_into","","",25,[[["self"],["t"]]]],[11,"to_string","","",25,[[["self"]],["string"]]],[11,"try_from","","",25,[[["u"]],["result"]]],[11,"try_into","","",25,[[],["result"]]],[11,"borrow","","",25,[[["self"]],["t"]]],[11,"borrow_mut","","",25,[[["self"]],["t"]]],[11,"type_id","","",25,[[["self"]],["typeid"]]],[11,"from","libslide::utils::grammar","",28,[[["t"]],["t"]]],[11,"into","","",28,[[],["u"]]],[11,"try_from","","",28,[[["u"]],["result"]]],[11,"try_into","","",28,[[],["result"]]],[11,"borrow","","",28,[[["self"]],["t"]]],[11,"borrow_mut","","",28,[[["self"]],["t"]]],[11,"type_id","","",28,[[["self"]],["typeid"]]],[11,"from","libslide::utils::iter","",29,[[["t"]],["t"]]],[11,"into","","",29,[[],["u"]]],[11,"into_iter","","",29,[[],["i"]]],[11,"try_from","","",29,[[["u"]],["result"]]],[11,"try_into","","",29,[[],["result"]]],[11,"borrow","","",29,[[["self"]],["t"]]],[11,"borrow_mut","","",29,[[["self"]],["t"]]],[11,"type_id","","",29,[[["self"]],["typeid"]]],[11,"from","","",30,[[["t"]],["t"]]],[11,"into","","",30,[[],["u"]]],[11,"into_iter","","",30,[[],["i"]]],[11,"try_from","","",30,[[["u"]],["result"]]],[11,"try_into","","",30,[[],["result"]]],[11,"borrow","","",30,[[["self"]],["t"]]],[11,"borrow_mut","","",30,[[["self"]],["t"]]],[11,"type_id","","",30,[[["self"]],["typeid"]]],[11,"new","libslide::parser::expression_parser","",6,[[["vec",["token"]],["token"]],["self"]]],[11,"errors","","",6,[[["self"]],["vec"]]],[11,"input","","",6,[[["self"]],["peekiter"]]],[11,"parse","","",6,[[["self"]],["stmt"]]],[11,"parse_float","","",6,[[["self"],["f64"]]]],[11,"parse_variable","","",6,[[["self"],["string"]]]],[11,"parse_var_pattern","","",6,[[["self"],["string"]]]],[11,"parse_const_pattern","","",6,[[["self"],["string"]]]],[11,"parse_any_pattern","","",6,[[["self"],["string"]]]],[11,"parse_open_paren","","",6,[[["self"]]]],[11,"parse_open_brace","","",6,[[["self"]]]],[11,"finish_expr","","",6,[[["self"]],["rc"]]],[11,"new","libslide::parser::expression_pattern_parser","",7,[[["vec",["token"]],["token"]],["self"]]],[11,"errors","","",7,[[["self"]],["vec"]]],[11,"input","","",7,[[["self"]],["peekiter"]]],[11,"parse","","",7,[[["self"]],[["rc",["exprpat"]],["exprpat"]]]],[11,"parse_float","","",7,[[["self"],["f64"]]]],[11,"parse_variable","","",7,[[["self"],["string"]]]],[11,"parse_var_pattern","","",7,[[["self"],["string"]]]],[11,"parse_const_pattern","","",7,[[["self"],["string"]]]],[11,"parse_any_pattern","","",7,[[["self"],["string"]]]],[11,"parse_open_paren","","",7,[[["self"]]]],[11,"parse_open_brace","","",7,[[["self"]]]],[11,"finish_expr","","",7,[[["self"]],["rc"]]],[11,"match_rule","libslide::evaluator_rules::pattern_match","",9,[[["expr"],["rc",["exprpat"]],["exprpat"],["rc",["expr"]]],[["option",["patternmatch"]],["patternmatch",["expr"]]]]],[11,"match_rule","","",9,[[["rc",["exprpat"]],["exprpat"]],[["option",["patternmatch"]],["patternmatch",["exprpat"]]]]],[11,"transform","","Transforms a pattern expression into an expression by…",9,[[["rc",["exprpat"]],["exprpat"],["self"]],[["expr"],["rc",["expr"]]]]],[11,"transform","","",9,[[["rc",["exprpat"]],["exprpat"],["self"]],[["rc",["exprpat"]],["exprpat"]]]],[11,"transform","libslide::evaluator_rules::rule","Attempts to apply a rule on a target expression by",16,[[["rc",["expr"]],["self"],["expr"]],[["expr"],["rc",["expr"]]]]],[11,"transform","","Bootstraps a rule with another (or possibly the same) rule.",16,[[["rc",["exprpat"]],["exprpat"],["self"]],[["rc",["exprpat"]],["exprpat"]]]],[11,"is_const","libslide::grammar::pattern","",25,[[["self"]],["bool"]]],[11,"is_const","libslide::grammar","",22,[[["self"]],["bool"]]],[11,"from","libslide::bignum::complex","",2,[[["u8"]],["self"]]],[11,"from","libslide::evaluator_rules::unbuilt_rule","",17,[[["str"]],["self"]]],[11,"from","libslide::grammar::pattern","",25,[[["binaryexpr"]],["self"]]],[11,"from","","",25,[[["unaryexpr"]],["self"]]],[11,"from","libslide::grammar","",21,[[["expr"]],["self"]]],[11,"from","","",21,[[["assignment"]],["self"]]],[11,"from","","",22,[[["f64"]],["self"]]],[11,"from","","",22,[[["binaryexpr"]],["self"]]],[11,"from","","",22,[[["unaryexpr"]],["self"]]],[11,"next","libslide::utils::iter","",29,[[["self"]],["option"]]],[11,"next","","",30,[[["self"]],["option"]]],[11,"clone","libslide::bignum::complex","",2,[[["self"]],["complex"]]],[11,"clone","libslide::scanner::types","",5,[[["self"]],["tokentype"]]],[11,"clone","","",4,[[["self"]],["token"]]],[11,"clone","libslide::evaluator_rules::registry","",13,[[["self"]],["rulename"]]],[11,"clone","libslide::evaluator_rules::rule","",14,[[["self"]],["patternmap"]]],[11,"clone","libslide::evaluator_rules::unbuilt_rule","",17,[[["self"]],["unbuiltrule"]]],[11,"clone","libslide::grammar::pattern","",25,[[["self"]],["exprpat"]]],[11,"clone","libslide::grammar","",21,[[["self"]],["stmt"]]],[11,"clone","","",18,[[["self"]],["assignment"]]],[11,"clone","","",22,[[["self"]],["expr"]]],[11,"clone","","",23,[[["self"]],["binaryoperator"]]],[11,"clone","","",19,[[["self"]],["binaryexpr"]]],[11,"clone","","",24,[[["self"]],["unaryoperator"]]],[11,"clone","","",20,[[["self"]],["unaryexpr"]]],[11,"default","libslide::bignum::complex","",2,[[],["complex"]]],[11,"default","libslide","",1,[[],["self"]]],[11,"default","libslide::evaluator_rules::pattern_match","",9,[[],["self"]]],[11,"default","libslide::evaluator_rules::registry","Constructs the default rule set.",11,[[],["self"]]],[11,"cmp","libslide","",0,[[["bignum"],["self"]],["ordering"]]],[11,"cmp","libslide::evaluator_rules::registry","",13,[[["self"]],["ordering"]]],[11,"cmp","libslide::grammar","",22,[[["self"]],["ordering"]]],[11,"eq","libslide","",0,[[["bignum"],["self"]],["bool"]]],[11,"eq","libslide::bignum::complex","",2,[[["self"]],["bool"]]],[11,"eq","libslide::scanner::types","",5,[[["self"],["tokentype"]],["bool"]]],[11,"ne","","",5,[[["self"],["tokentype"]],["bool"]]],[11,"eq","","",4,[[["token"],["self"]],["bool"]]],[11,"ne","","",4,[[["token"],["self"]],["bool"]]],[11,"eq","libslide::evaluator_rules::registry","",13,[[["self"],["rulename"]],["bool"]]],[11,"eq","libslide::grammar::pattern","",25,[[["self"],["exprpat"]],["bool"]]],[11,"eq","libslide::grammar","",22,[[["expr"],["self"]],["bool"]]],[11,"ne","","",22,[[["expr"],["self"]],["bool"]]],[11,"eq","","",23,[[["self"],["binaryoperator"]],["bool"]]],[11,"eq","","",19,[[["binaryexpr"],["self"]],["bool"]]],[11,"ne","","",19,[[["binaryexpr"],["self"]],["bool"]]],[11,"eq","","",24,[[["self"],["unaryoperator"]],["bool"]]],[11,"eq","","",20,[[["unaryexpr"],["self"]],["bool"]]],[11,"ne","","",20,[[["unaryexpr"],["self"]],["bool"]]],[11,"partial_cmp","libslide","",0,[[["bignum"],["self"]],[["ordering"],["option",["ordering"]]]]],[11,"partial_cmp","libslide::evaluator_rules::registry","",13,[[["self"]],[["ordering"],["option",["ordering"]]]]],[11,"partial_cmp","libslide::grammar","",22,[[["self"]],[["ordering"],["option",["ordering"]]]]],[11,"partial_cmp","","",23,[[["self"]],[["ordering"],["option",["ordering"]]]]],[11,"fmt","libslide::bignum::complex","",2,[[["formatter"],["self"]],["result"]]],[11,"fmt","libslide::scanner::types","",5,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",4,[[["formatter"],["self"]],["result"]]],[11,"fmt","libslide::evaluator_rules::registry","",13,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",12,[[["formatter"],["self"]],["result"]]],[11,"fmt","libslide::evaluator_rules::rule","",14,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",15,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",16,[[["formatter"],["self"]],["result"]]],[11,"fmt","libslide::grammar::pattern","",25,[[["formatter"],["self"]],["result"]]],[11,"fmt","libslide::grammar","",22,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",23,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",19,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",24,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",20,[[["formatter"],["self"]],["result"]]],[11,"fmt","libslide::bignum::complex","",2,[[["formatter"],["self"]],["result"]]],[11,"fmt","libslide","",0,[[["formatter"],["self"]],["result"]]],[11,"fmt","libslide::scanner::types","",4,[[["formatter"],["self"]],["result"]]],[11,"fmt","libslide::evaluator_rules::registry","",12,[[["formatter"],["self"]],["result"]]],[11,"fmt","libslide::evaluator_rules::rule","",14,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",15,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",16,[[["formatter"],["self"]],["result"]]],[11,"fmt","libslide::grammar::pattern","",25,[[["formatter"],["self"]],["result"]]],[11,"fmt","libslide::grammar","",21,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",18,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",22,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",23,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",19,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",19,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",24,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",20,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",20,[[["formatter"],["self"]],["result"]]],[11,"div","libslide::bignum::complex","",2,[[["complex"]],["complex"]]],[11,"sub","","",2,[[["complex"]],["complex"]]],[11,"sub","libslide","",0,[[["bignum"]],["bignum"]]],[11,"add","","",0,[[["bignum"]],["bignum"]]],[11,"add","libslide::bignum::complex","",2,[[["complex"]],["complex"]]],[11,"mul","","",2,[[["complex"]],["complex"]]],[11,"mul","libslide","",0,[[["bignum"]],["bignum"]]],[11,"neg","","",0,[[],["bignum"]]],[11,"hash","libslide::evaluator_rules::registry","",13,[[["self"],["__h"]]]],[11,"hash","libslide::grammar::pattern","",25,[[["self"],["h"]]]],[11,"hash","libslide::grammar","",22,[[["self"],["h"]]]],[11,"hash","","",23,[[["self"],["__h"]]]],[11,"hash","","",19,[[["self"],["__h"]]]],[11,"hash","","",24,[[["self"],["__h"]]]],[11,"hash","","",20,[[["self"],["__h"]]]],[11,"try_from","libslide::bignum::complex","",2,[[["string"]],[["str"],["result",["str"]]]]],[11,"try_from","libslide::grammar","",23,[[["token"]],["result"]]],[11,"try_from","","",24,[[["token"]],["result"]]]],"p":[[3,"Bignum"],[3,"EvaluatorContext"],[3,"Complex"],[3,"Scanner"],[3,"Token"],[4,"TokenType"],[3,"ExpressionParser"],[3,"ExpressionPatternParser"],[8,"Parser"],[3,"PatternMatch"],[8,"MatchRule"],[3,"RuleSet"],[3,"BuildRuleErrors"],[4,"RuleName"],[3,"PatternMap"],[3,"UnresolvedMapping"],[4,"Rule"],[4,"UnbuiltRule"],[3,"Assignment"],[3,"BinaryExpr"],[3,"UnaryExpr"],[4,"Stmt"],[4,"Expr"],[4,"BinaryOperator"],[4,"UnaryOperator"],[4,"ExprPat"],[8,"Transformer"],[8,"Expression"],[4,"UnflattenStrategy"],[3,"PeekingTakeWhile"],[3,"PeekIter"],[8,"StringUtils"]]};
searchIndex["num_traits"] = {"doc":"Numeric traits for generic mathematics","i":[[3,"ParseFloatError","num_traits","",null,null],[12,"kind","","",0,null],[4,"FloatErrorKind","","",null,null],[13,"Empty","","",1,null],[13,"Invalid","","",1,null],[5,"clamp","","A value bounded by a minimum and a maximum",null,[[["partialord"]],["partialord"]]],[5,"clamp_min","","A value bounded by a minimum value",null,[[["partialord"]],["partialord"]]],[5,"clamp_max","","A value bounded by a maximum value",null,[[["partialord"]],["partialord"]]],[0,"bounds","","",null,null],[8,"Bounded","num_traits::bounds","Numbers which have upper and lower bounds",null,null],[10,"min_value","","returns the smallest finite number this type can represent",2,[[],["self"]]],[10,"max_value","","returns the largest finite number this type can represent",2,[[],["self"]]],[0,"cast","num_traits","",null,null],[5,"cast","num_traits::cast","Cast from one machine scalar to another.",null,[[["numcast"]],[["option"],["numcast"]]]],[8,"ToPrimitive","","A generic trait for converting a value to a number.",null,null],[11,"to_isize","","Converts the value of `self` to an `isize`. If the value…",3,[[["self"]],[["isize"],["option",["isize"]]]]],[11,"to_i8","","Converts the value of `self` to an `i8`. If the value…",3,[[["self"]],[["option",["i8"]],["i8"]]]],[11,"to_i16","","Converts the value of `self` to an `i16`. If the value…",3,[[["self"]],[["option",["i16"]],["i16"]]]],[11,"to_i32","","Converts the value of `self` to an `i32`. If the value…",3,[[["self"]],[["i32"],["option",["i32"]]]]],[10,"to_i64","","Converts the value of `self` to an `i64`. If the value…",3,[[["self"]],[["i64"],["option",["i64"]]]]],[11,"to_i128","","Converts the value of `self` to an `i128`. If the value…",3,[[["self"]],[["option",["i128"]],["i128"]]]],[11,"to_usize","","Converts the value of `self` to a `usize`. If the value…",3,[[["self"]],[["option",["usize"]],["usize"]]]],[11,"to_u8","","Converts the value of `self` to a `u8`. If the value…",3,[[["self"]],[["option",["u8"]],["u8"]]]],[11,"to_u16","","Converts the value of `self` to a `u16`. If the value…",3,[[["self"]],[["option",["u16"]],["u16"]]]],[11,"to_u32","","Converts the value of `self` to a `u32`. If the value…",3,[[["self"]],[["u32"],["option",["u32"]]]]],[10,"to_u64","","Converts the value of `self` to a `u64`. If the value…",3,[[["self"]],[["option",["u64"]],["u64"]]]],[11,"to_u128","","Converts the value of `self` to a `u128`. If the value…",3,[[["self"]],[["u128"],["option",["u128"]]]]],[11,"to_f32","","Converts the value of `self` to an `f32`. If the value…",3,[[["self"]],[["option",["f32"]],["f32"]]]],[11,"to_f64","","Converts the value of `self` to an `f64`. If the value…",3,[[["self"]],[["option",["f64"]],["f64"]]]],[8,"FromPrimitive","","A generic trait for converting a number to a value.",null,null],[11,"from_isize","","Converts an `isize` to return an optional value of this…",4,[[["isize"]],["option"]]],[11,"from_i8","","Converts an `i8` to return an optional value of this type.…",4,[[["i8"]],["option"]]],[11,"from_i16","","Converts an `i16` to return an optional value of this…",4,[[["i16"]],["option"]]],[11,"from_i32","","Converts an `i32` to return an optional value of this…",4,[[["i32"]],["option"]]],[10,"from_i64","","Converts an `i64` to return an optional value of this…",4,[[["i64"]],["option"]]],[11,"from_i128","","Converts an `i128` to return an optional value of this…",4,[[["i128"]],["option"]]],[11,"from_usize","","Converts a `usize` to return an optional value of this…",4,[[["usize"]],["option"]]],[11,"from_u8","","Converts an `u8` to return an optional value of this type.…",4,[[["u8"]],["option"]]],[11,"from_u16","","Converts an `u16` to return an optional value of this…",4,[[["u16"]],["option"]]],[11,"from_u32","","Converts an `u32` to return an optional value of this…",4,[[["u32"]],["option"]]],[10,"from_u64","","Converts an `u64` to return an optional value of this…",4,[[["u64"]],["option"]]],[11,"from_u128","","Converts an `u128` to return an optional value of this…",4,[[["u128"]],["option"]]],[11,"from_f32","","Converts a `f32` to return an optional value of this type.…",4,[[["f32"]],["option"]]],[11,"from_f64","","Converts a `f64` to return an optional value of this type.…",4,[[["f64"]],["option"]]],[8,"NumCast","","An interface for casting between machine scalars.",null,null],[10,"from","","Creates a number from another value that can be converted…",5,[[["toprimitive"]],["option"]]],[8,"AsPrimitive","","A generic interface for casting between machine scalars…",null,null],[10,"as_","","Convert a value to another, using the `as` operator.",6,[[],["t"]]],[0,"float","num_traits","",null,null],[8,"FloatCore","num_traits::float","Generic trait for floating point numbers that works with…",null,null],[10,"infinity","","Returns positive infinity.",7,[[],["self"]]],[10,"neg_infinity","","Returns negative infinity.",7,[[],["self"]]],[10,"nan","","Returns NaN.",7,[[],["self"]]],[10,"neg_zero","","Returns `-0.0`.",7,[[],["self"]]],[10,"min_value","","Returns the smallest finite value that this type can…",7,[[],["self"]]],[10,"min_positive_value","","Returns the smallest positive, normalized value that this…",7,[[],["self"]]],[10,"epsilon","","Returns epsilon, a small positive value.",7,[[],["self"]]],[10,"max_value","","Returns the largest finite value that this type can…",7,[[],["self"]]],[11,"is_nan","","Returns `true` if the number is NaN.",7,[[],["bool"]]],[11,"is_infinite","","Returns `true` if the number is infinite.",7,[[],["bool"]]],[11,"is_finite","","Returns `true` if the number is neither infinite or NaN.",7,[[],["bool"]]],[11,"is_normal","","Returns `true` if the number is neither zero, infinite,…",7,[[],["bool"]]],[10,"classify","","Returns the floating point category of the number. If only…",7,[[],["fpcategory"]]],[11,"floor","","Returns the largest integer less than or equal to a number.",7,[[],["self"]]],[11,"ceil","","Returns the smallest integer greater than or equal to a…",7,[[],["self"]]],[11,"round","","Returns the nearest integer to a number. Round half-way…",7,[[],["self"]]],[11,"trunc","","Return the integer part of a number.",7,[[],["self"]]],[11,"fract","","Returns the fractional part of a number.",7,[[],["self"]]],[11,"abs","","Computes the absolute value of `self`. Returns…",7,[[],["self"]]],[11,"signum","","Returns a number that represents the sign of `self`.",7,[[],["self"]]],[11,"is_sign_positive","","Returns `true` if `self` is positive, including `+0.0` and…",7,[[],["bool"]]],[11,"is_sign_negative","","Returns `true` if `self` is negative, including `-0.0` and…",7,[[],["bool"]]],[11,"min","","Returns the minimum of the two numbers.",7,[[],["self"]]],[11,"max","","Returns the maximum of the two numbers.",7,[[],["self"]]],[11,"recip","","Returns the reciprocal (multiplicative inverse) of the…",7,[[],["self"]]],[11,"powi","","Raise a number to an integer power.",7,[[["i32"]],["self"]]],[10,"to_degrees","","Converts to degrees, assuming the number is in radians.",7,[[],["self"]]],[10,"to_radians","","Converts to radians, assuming the number is in degrees.",7,[[],["self"]]],[10,"integer_decode","","Returns the mantissa, base 2 exponent, and sign as…",7,[[]]],[8,"Float","","Generic trait for floating point numbers",null,null],[10,"nan","","Returns the `NaN` value.",8,[[],["self"]]],[10,"infinity","","Returns the infinite value.",8,[[],["self"]]],[10,"neg_infinity","","Returns the negative infinite value.",8,[[],["self"]]],[10,"neg_zero","","Returns `-0.0`.",8,[[],["self"]]],[10,"min_value","","Returns the smallest finite value that this type can…",8,[[],["self"]]],[10,"min_positive_value","","Returns the smallest positive, normalized value that this…",8,[[],["self"]]],[11,"epsilon","","Returns epsilon, a small positive value.",8,[[],["self"]]],[10,"max_value","","Returns the largest finite value that this type can…",8,[[],["self"]]],[10,"is_nan","","Returns `true` if this value is `NaN` and false otherwise.",8,[[],["bool"]]],[10,"is_infinite","","Returns `true` if this value is positive infinity or…",8,[[],["bool"]]],[10,"is_finite","","Returns `true` if this number is neither infinite nor `NaN`.",8,[[],["bool"]]],[10,"is_normal","","Returns `true` if the number is neither zero, infinite,…",8,[[],["bool"]]],[10,"classify","","Returns the floating point category of the number. If only…",8,[[],["fpcategory"]]],[10,"floor","","Returns the largest integer less than or equal to a number.",8,[[],["self"]]],[10,"ceil","","Returns the smallest integer greater than or equal to a…",8,[[],["self"]]],[10,"round","","Returns the nearest integer to a number. Round half-way…",8,[[],["self"]]],[10,"trunc","","Return the integer part of a number.",8,[[],["self"]]],[10,"fract","","Returns the fractional part of a number.",8,[[],["self"]]],[10,"abs","","Computes the absolute value of `self`. Returns…",8,[[],["self"]]],[10,"signum","","Returns a number that represents the sign of `self`.",8,[[],["self"]]],[10,"is_sign_positive","","Returns `true` if `self` is positive, including `+0.0`,…",8,[[],["bool"]]],[10,"is_sign_negative","","Returns `true` if `self` is negative, including `-0.0`,…",8,[[],["bool"]]],[10,"mul_add","","Fused multiply-add. Computes `(self * a) + b` with only…",8,[[],["self"]]],[10,"recip","","Take the reciprocal (inverse) of a number, `1/x`.",8,[[],["self"]]],[10,"powi","","Raise a number to an integer power.",8,[[["i32"]],["self"]]],[10,"powf","","Raise a number to a floating point power.",8,[[],["self"]]],[10,"sqrt","","Take the square root of a number.",8,[[],["self"]]],[10,"exp","","Returns `e^(self)`, (the exponential function).",8,[[],["self"]]],[10,"exp2","","Returns `2^(self)`.",8,[[],["self"]]],[10,"ln","","Returns the natural logarithm of the number.",8,[[],["self"]]],[10,"log","","Returns the logarithm of the number with respect to an…",8,[[],["self"]]],[10,"log2","","Returns the base 2 logarithm of the number.",8,[[],["self"]]],[10,"log10","","Returns the base 10 logarithm of the number.",8,[[],["self"]]],[11,"to_degrees","","Converts radians to degrees.",8,[[],["self"]]],[11,"to_radians","","Converts degrees to radians.",8,[[],["self"]]],[10,"max","","Returns the maximum of the two numbers.",8,[[],["self"]]],[10,"min","","Returns the minimum of the two numbers.",8,[[],["self"]]],[10,"abs_sub","","The positive difference of two numbers.",8,[[],["self"]]],[10,"cbrt","","Take the cubic root of a number.",8,[[],["self"]]],[10,"hypot","","Calculate the length of the hypotenuse of a right-angle…",8,[[],["self"]]],[10,"sin","","Computes the sine of a number (in radians).",8,[[],["self"]]],[10,"cos","","Computes the cosine of a number (in radians).",8,[[],["self"]]],[10,"tan","","Computes the tangent of a number (in radians).",8,[[],["self"]]],[10,"asin","","Computes the arcsine of a number. Return value is in…",8,[[],["self"]]],[10,"acos","","Computes the arccosine of a number. Return value is in…",8,[[],["self"]]],[10,"atan","","Computes the arctangent of a number. Return value is in…",8,[[],["self"]]],[10,"atan2","","Computes the four quadrant arctangent of `self` (`y`) and…",8,[[],["self"]]],[10,"sin_cos","","Simultaneously computes the sine and cosine of the number,…",8,[[]]],[10,"exp_m1","","Returns `e^(self) - 1` in a way that is accurate even if…",8,[[],["self"]]],[10,"ln_1p","","Returns `ln(1+n)` (natural logarithm) more accurately than…",8,[[],["self"]]],[10,"sinh","","Hyperbolic sine function.",8,[[],["self"]]],[10,"cosh","","Hyperbolic cosine function.",8,[[],["self"]]],[10,"tanh","","Hyperbolic tangent function.",8,[[],["self"]]],[10,"asinh","","Inverse hyperbolic sine function.",8,[[],["self"]]],[10,"acosh","","Inverse hyperbolic cosine function.",8,[[],["self"]]],[10,"atanh","","Inverse hyperbolic tangent function.",8,[[],["self"]]],[10,"integer_decode","","Returns the mantissa, base 2 exponent, and sign as…",8,[[]]],[8,"FloatConst","","",null,null],[10,"E","","Return Euler’s number.",9,[[],["self"]]],[10,"FRAC_1_PI","","Return `1.0 / π`.",9,[[],["self"]]],[10,"FRAC_1_SQRT_2","","Return `1.0 / sqrt(2.0)`.",9,[[],["self"]]],[10,"FRAC_2_PI","","Return `2.0 / π`.",9,[[],["self"]]],[10,"FRAC_2_SQRT_PI","","Return `2.0 / sqrt(π)`.",9,[[],["self"]]],[10,"FRAC_PI_2","","Return `π / 2.0`.",9,[[],["self"]]],[10,"FRAC_PI_3","","Return `π / 3.0`.",9,[[],["self"]]],[10,"FRAC_PI_4","","Return `π / 4.0`.",9,[[],["self"]]],[10,"FRAC_PI_6","","Return `π / 6.0`.",9,[[],["self"]]],[10,"FRAC_PI_8","","Return `π / 8.0`.",9,[[],["self"]]],[10,"LN_10","","Return `ln(10.0)`.",9,[[],["self"]]],[10,"LN_2","","Return `ln(2.0)`.",9,[[],["self"]]],[10,"LOG10_E","","Return `log10(e)`.",9,[[],["self"]]],[10,"LOG2_E","","Return `log2(e)`.",9,[[],["self"]]],[10,"PI","","Return Archimedes’ constant `π`.",9,[[],["self"]]],[10,"SQRT_2","","Return `sqrt(2.0)`.",9,[[],["self"]]],[11,"TAU","","Return the full circle constant `τ`.",9,[[],["self"]]],[0,"identities","num_traits","",null,null],[5,"zero","num_traits::identities","Returns the additive identity, `0`.",null,[[],["zero"]]],[5,"one","","Returns the multiplicative identity, `1`.",null,[[],["one"]]],[8,"Zero","","Defines an additive identity element for `Self`.",null,null],[10,"zero","","Returns the additive identity element of `Self`, `0`. #…",10,[[],["self"]]],[11,"set_zero","","Sets `self` to the additive identity element of `Self`, `0`.",10,[[["self"]]]],[10,"is_zero","","Returns `true` if `self` is equal to the additive identity.",10,[[["self"]],["bool"]]],[8,"One","","Defines a multiplicative identity element for `Self`.",null,null],[10,"one","","Returns the multiplicative identity element of `Self`, `1`.",11,[[],["self"]]],[11,"set_one","","Sets `self` to the multiplicative identity element of…",11,[[["self"]]]],[11,"is_one","","Returns `true` if `self` is equal to the multiplicative…",11,[[["self"]],["bool"]]],[0,"int","num_traits","",null,null],[8,"PrimInt","num_traits::int","Generic trait for primitive integers.",null,null],[10,"count_ones","","Returns the number of ones in the binary representation of…",12,[[],["u32"]]],[10,"count_zeros","","Returns the number of zeros in the binary representation…",12,[[],["u32"]]],[10,"leading_zeros","","Returns the number of leading zeros in the binary…",12,[[],["u32"]]],[10,"trailing_zeros","","Returns the number of trailing zeros in the binary…",12,[[],["u32"]]],[10,"rotate_left","","Shifts the bits to the left by a specified amount amount,…",12,[[["u32"]],["self"]]],[10,"rotate_right","","Shifts the bits to the right by a specified amount amount,…",12,[[["u32"]],["self"]]],[10,"signed_shl","","Shifts the bits to the left by a specified amount amount,…",12,[[["u32"]],["self"]]],[10,"signed_shr","","Shifts the bits to the right by a specified amount amount,…",12,[[["u32"]],["self"]]],[10,"unsigned_shl","","Shifts the bits to the left by a specified amount amount,…",12,[[["u32"]],["self"]]],[10,"unsigned_shr","","Shifts the bits to the right by a specified amount amount,…",12,[[["u32"]],["self"]]],[10,"swap_bytes","","Reverses the byte order of the integer.",12,[[],["self"]]],[10,"from_be","","Convert an integer from big endian to the target's…",12,[[],["self"]]],[10,"from_le","","Convert an integer from little endian to the target's…",12,[[],["self"]]],[10,"to_be","","Convert `self` to big endian from the target's endianness.",12,[[],["self"]]],[10,"to_le","","Convert `self` to little endian from the target's…",12,[[],["self"]]],[10,"pow","","Raises self to the power of `exp`, using exponentiation by…",12,[[["u32"]],["self"]]],[0,"ops","num_traits","",null,null],[0,"checked","num_traits::ops","",null,null],[8,"CheckedAdd","num_traits::ops::checked","Performs addition that returns `None` instead of wrapping…",null,null],[10,"checked_add","","Adds two numbers, checking for overflow. If overflow…",13,[[["self"]],["option"]]],[8,"CheckedSub","","Performs subtraction that returns `None` instead of…",null,null],[10,"checked_sub","","Subtracts two numbers, checking for underflow. If…",14,[[["self"]],["option"]]],[8,"CheckedMul","","Performs multiplication that returns `None` instead of…",null,null],[10,"checked_mul","","Multiplies two numbers, checking for underflow or…",15,[[["self"]],["option"]]],[8,"CheckedDiv","","Performs division that returns `None` instead of panicking…",null,null],[10,"checked_div","","Divides two numbers, checking for underflow, overflow and…",16,[[["self"]],["option"]]],[8,"CheckedRem","","Performs an integral remainder that returns `None` instead…",null,null],[10,"checked_rem","","Finds the remainder of dividing two numbers, checking for…",17,[[["self"]],["option"]]],[8,"CheckedNeg","","Performs negation that returns `None` if the result can't…",null,null],[10,"checked_neg","","Negates a number, returning `None` for results that can't…",18,[[["self"]],["option"]]],[8,"CheckedShl","","Performs a left shift that returns `None` on shifts larger…",null,null],[10,"checked_shl","","Checked shift left. Computes `self << rhs`, returning…",19,[[["u32"],["self"]],["option"]]],[8,"CheckedShr","","Performs a right shift that returns `None` on shifts…",null,null],[10,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning…",20,[[["u32"],["self"]],["option"]]],[0,"inv","num_traits::ops","",null,null],[8,"Inv","num_traits::ops::inv","Unary operator for retrieving the multiplicative inverse,…",null,null],[16,"Output","","The result after applying the operator.",21,null],[10,"inv","","Returns the multiplicative inverse of `self`.",21,[[]]],[0,"mul_add","num_traits::ops","",null,null],[8,"MulAdd","num_traits::ops::mul_add","Fused multiply-add. Computes `(self * a) + b` with only…",null,null],[16,"Output","","The resulting type after applying the fused multiply-add.",22,null],[10,"mul_add","","Performs the fused multiply-add operation.",22,[[["a"],["b"]]]],[8,"MulAddAssign","","The fused multiply-add assignment operation.",null,null],[10,"mul_add_assign","","Performs the fused multiply-add operation.",23,[[["a"],["self"],["b"]]]],[0,"saturating","num_traits::ops","",null,null],[8,"Saturating","num_traits::ops::saturating","Saturating math operations",null,null],[10,"saturating_add","","Saturating addition operator. Returns a+b, saturating at…",24,[[],["self"]]],[10,"saturating_sub","","Saturating subtraction operator. Returns a-b, saturating…",24,[[],["self"]]],[0,"wrapping","num_traits::ops","",null,null],[8,"WrappingAdd","num_traits::ops::wrapping","Performs addition that wraps around on overflow.",null,null],[10,"wrapping_add","","Wrapping (modular) addition. Computes `self + other`,…",25,[[["self"]],["self"]]],[8,"WrappingSub","","Performs subtraction that wraps around on overflow.",null,null],[10,"wrapping_sub","","Wrapping (modular) subtraction. Computes `self - other`,…",26,[[["self"]],["self"]]],[8,"WrappingMul","","Performs multiplication that wraps around on overflow.",null,null],[10,"wrapping_mul","","Wrapping (modular) multiplication. Computes `self *…",27,[[["self"]],["self"]]],[8,"WrappingShl","","Performs a left shift that does not panic.",null,null],[10,"wrapping_shl","","Panic-free bitwise shift-left; yields `self << mask(rhs)`,…",28,[[["u32"],["self"]],["self"]]],[8,"WrappingShr","","Performs a right shift that does not panic.",null,null],[10,"wrapping_shr","","Panic-free bitwise shift-right; yields `self >>…",29,[[["u32"],["self"]],["self"]]],[0,"pow","num_traits","",null,null],[5,"pow","num_traits::pow","Raises a value to the power of exp, using exponentiation…",null,[[["one"],["usize"],["clone"],["mul"]],[["one"],["clone"],["mul"]]]],[5,"checked_pow","","Raises a value to the power of exp, returning `None` if an…",null,[[["one"],["usize"],["clone"],["checkedmul"]],[["one"],["clone"],["checkedmul"],["option"]]]],[8,"Pow","","Binary operator for raising a value to a power.",null,null],[16,"Output","","The result after applying the operator.",30,null],[10,"pow","","Returns `self` to the power `rhs`.",30,[[["rhs"]]]],[0,"real","num_traits","",null,null],[8,"Real","num_traits::real","A trait for real number types that do not necessarily have…",null,null],[10,"min_value","","Returns the smallest finite value that this type can…",31,[[],["self"]]],[10,"min_positive_value","","Returns the smallest positive, normalized value that this…",31,[[],["self"]]],[10,"epsilon","","Returns epsilon, a small positive value.",31,[[],["self"]]],[10,"max_value","","Returns the largest finite value that this type can…",31,[[],["self"]]],[10,"floor","","Returns the largest integer less than or equal to a number.",31,[[],["self"]]],[10,"ceil","","Returns the smallest integer greater than or equal to a…",31,[[],["self"]]],[10,"round","","Returns the nearest integer to a number. Round half-way…",31,[[],["self"]]],[10,"trunc","","Return the integer part of a number.",31,[[],["self"]]],[10,"fract","","Returns the fractional part of a number.",31,[[],["self"]]],[10,"abs","","Computes the absolute value of `self`. Returns…",31,[[],["self"]]],[10,"signum","","Returns a number that represents the sign of `self`.",31,[[],["self"]]],[10,"is_sign_positive","","Returns `true` if `self` is positive, including `+0.0`,…",31,[[],["bool"]]],[10,"is_sign_negative","","Returns `true` if `self` is negative, including `-0.0`,…",31,[[],["bool"]]],[10,"mul_add","","Fused multiply-add. Computes `(self * a) + b` with only…",31,[[],["self"]]],[10,"recip","","Take the reciprocal (inverse) of a number, `1/x`.",31,[[],["self"]]],[10,"powi","","Raise a number to an integer power.",31,[[["i32"]],["self"]]],[10,"powf","","Raise a number to a real number power.",31,[[],["self"]]],[10,"sqrt","","Take the square root of a number.",31,[[],["self"]]],[10,"exp","","Returns `e^(self)`, (the exponential function).",31,[[],["self"]]],[10,"exp2","","Returns `2^(self)`.",31,[[],["self"]]],[10,"ln","","Returns the natural logarithm of the number.",31,[[],["self"]]],[10,"log","","Returns the logarithm of the number with respect to an…",31,[[],["self"]]],[10,"log2","","Returns the base 2 logarithm of the number.",31,[[],["self"]]],[10,"log10","","Returns the base 10 logarithm of the number.",31,[[],["self"]]],[10,"to_degrees","","Converts radians to degrees.",31,[[],["self"]]],[10,"to_radians","","Converts degrees to radians.",31,[[],["self"]]],[10,"max","","Returns the maximum of the two numbers.",31,[[],["self"]]],[10,"min","","Returns the minimum of the two numbers.",31,[[],["self"]]],[10,"abs_sub","","The positive difference of two numbers.",31,[[],["self"]]],[10,"cbrt","","Take the cubic root of a number.",31,[[],["self"]]],[10,"hypot","","Calculate the length of the hypotenuse of a right-angle…",31,[[],["self"]]],[10,"sin","","Computes the sine of a number (in radians).",31,[[],["self"]]],[10,"cos","","Computes the cosine of a number (in radians).",31,[[],["self"]]],[10,"tan","","Computes the tangent of a number (in radians).",31,[[],["self"]]],[10,"asin","","Computes the arcsine of a number. Return value is in…",31,[[],["self"]]],[10,"acos","","Computes the arccosine of a number. Return value is in…",31,[[],["self"]]],[10,"atan","","Computes the arctangent of a number. Return value is in…",31,[[],["self"]]],[10,"atan2","","Computes the four quadrant arctangent of `self` (`y`) and…",31,[[],["self"]]],[10,"sin_cos","","Simultaneously computes the sine and cosine of the number,…",31,[[]]],[10,"exp_m1","","Returns `e^(self) - 1` in a way that is accurate even if…",31,[[],["self"]]],[10,"ln_1p","","Returns `ln(1+n)` (natural logarithm) more accurately than…",31,[[],["self"]]],[10,"sinh","","Hyperbolic sine function.",31,[[],["self"]]],[10,"cosh","","Hyperbolic cosine function.",31,[[],["self"]]],[10,"tanh","","Hyperbolic tangent function.",31,[[],["self"]]],[10,"asinh","","Inverse hyperbolic sine function.",31,[[],["self"]]],[10,"acosh","","Inverse hyperbolic cosine function.",31,[[],["self"]]],[10,"atanh","","Inverse hyperbolic tangent function.",31,[[],["self"]]],[0,"sign","num_traits","",null,null],[5,"abs","num_traits::sign","Computes the absolute value.",null,[[["signed"]],["signed"]]],[5,"abs_sub","","The positive difference of two numbers.",null,[[["signed"]],["signed"]]],[5,"signum","","Returns the sign of the number.",null,[[["signed"]],["signed"]]],[8,"Signed","","Useful functions for signed numbers (i.e. numbers that can…",null,null],[10,"abs","","Computes the absolute value.",32,[[["self"]],["self"]]],[10,"abs_sub","","The positive difference of two numbers.",32,[[["self"]],["self"]]],[10,"signum","","Returns the sign of the number.",32,[[["self"]],["self"]]],[10,"is_positive","","Returns true if the number is positive and false if the…",32,[[["self"]],["bool"]]],[10,"is_negative","","Returns true if the number is negative and false if the…",32,[[["self"]],["bool"]]],[8,"Unsigned","","A trait for values which cannot be negative",null,null],[8,"Num","num_traits","The base trait for numeric types, covering `0` and `1`…",null,null],[16,"FromStrRadixErr","","",33,null],[10,"from_str_radix","","Convert from a string and radix <= 36.",33,[[["str"],["u32"]],["result"]]],[8,"NumOps","","The trait for types implementing basic numeric operations",null,null],[8,"NumRef","","The trait for `Num` types which also implement numeric…",null,null],[8,"RefNum","","The trait for references which implement numeric…",null,null],[8,"NumAssignOps","","The trait for types implementing numeric assignment…",null,null],[8,"NumAssign","","The trait for `Num` types which also implement assignment…",null,null],[8,"NumAssignRef","","The trait for `NumAssign` types which also implement…",null,null],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"into","","",0,[[],["u"]]],[11,"try_into","","",0,[[],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"type_id","","",0,[[["self"]],["typeid"]]],[11,"to_string","","",0,[[["self"]],["string"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"into","","",1,[[],["u"]]],[11,"try_into","","",1,[[],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"type_id","","",1,[[["self"]],["typeid"]]],[11,"fmt","","",1,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",0,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]]],"p":[[3,"ParseFloatError"],[4,"FloatErrorKind"],[8,"Bounded"],[8,"ToPrimitive"],[8,"FromPrimitive"],[8,"NumCast"],[8,"AsPrimitive"],[8,"FloatCore"],[8,"Float"],[8,"FloatConst"],[8,"Zero"],[8,"One"],[8,"PrimInt"],[8,"CheckedAdd"],[8,"CheckedSub"],[8,"CheckedMul"],[8,"CheckedDiv"],[8,"CheckedRem"],[8,"CheckedNeg"],[8,"CheckedShl"],[8,"CheckedShr"],[8,"Inv"],[8,"MulAdd"],[8,"MulAddAssign"],[8,"Saturating"],[8,"WrappingAdd"],[8,"WrappingSub"],[8,"WrappingMul"],[8,"WrappingShl"],[8,"WrappingShr"],[8,"Pow"],[8,"Real"],[8,"Signed"],[8,"Num"]]};
searchIndex["slide"] = {"doc":"","i":[[5,"main","slide","",null,[[],[["string"],["result",["string"]]]]]],"p":[]};
addSearchOptions(searchIndex);initSearch(searchIndex);